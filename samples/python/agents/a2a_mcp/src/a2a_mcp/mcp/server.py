# type: ignore
import json
import os
import sqlite3
import traceback
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, Optional

import google.generativeai as genai
import numpy as np
import pandas as pd
import requests
import serpapi
from mcp.server.fastmcp import FastMCP
from mcp.server.fastmcp.utilities.logging import get_logger

from a2a_mcp.common.utils import init_api_key

logger = get_logger(__name__)
AGENT_CARDS_DIR = "agent_cards"
MODEL = "models/embedding-001"
SQLLITE_DB = "travel_agency.db"
PLACES_API_URL = "https://places.googleapis.com/v1/places:searchText"


def generate_embeddings(text):
    """Generates embeddings for the given text using Google Generative AI.
    Args:
        text: The input string for which to generate embeddings.
    Returns:
        A list of embeddings representing the input text.
    """
    return genai.embed_content(
        model=MODEL,
        content=text,
        task_type="retrieval_document",
    )["embedding"]


def load_agent_cards():
    """Loads agent card data from JSON files within a specified directory.

    Returns:
        A list containing JSON data from an agent card file found in the specified directory.
        Returns an empty list if the directory is empty, contains no '.json' files,
        or if all '.json' files encounter errors during processing.
    """
    card_uris = []
    agent_cards = []
    if not os.path.isdir(AGENT_CARDS_DIR):
        logger.error(
            f"Agent cards directory not found or is not a directory: {AGENT_CARDS_DIR}"
        )
        return agent_cards

    logger.info(f"Loading agent cards from card repo: {AGENT_CARDS_DIR}")

    for filename in os.listdir(AGENT_CARDS_DIR):
        if filename.lower().endswith(".json"):
            file_path = os.path.join(AGENT_CARDS_DIR, filename)

            if os.path.isfile(file_path):
                logger.info(f"Reading file: {filename}")
                try:
                    with open(
                        file_path, "r", encoding="utf-8"
                    ) as f:  # Specify encoding
                        data = json.load(f)
                        card_uris.append(
                            f"resource://agent_cards/{Path(filename).stem}"
                        )
                        agent_cards.append(data)
                except json.JSONDecodeError as jde:
                    logger.error(f"JSON Decoder Error {jde}")
                except IOError as e:
                    logger.error(f"Error reading file {filename}: {e}.")
                except Exception as e:
                    logger.error(
                        f"An unexpected error occurred processing {filename}: {e}",
                        exc_info=True,
                    )
    logger.info(f"Finished loading agent cards. Found {len(agent_cards)} cards.")
    return card_uris, agent_cards


def build_agent_card_embeddings() -> pd.DataFrame:
    """Loads agent cards, generates embeddings for them, and returns a DataFrame.

    Returns:
        Optional[pd.DataFrame]: A Pandas DataFrame containing the original
        'agent_card' data and their corresponding 'Embeddings'. Returns None
        if no agent cards were loaded initially or if an exception occurred
        during the embedding generation process.
    """

    card_uris, agent_cards = load_agent_cards()
    logger.info("Generating Embeddings for agent cards")
    try:
        if agent_cards:
            df = pd.DataFrame({"card_uri": card_uris, "agent_card": agent_cards})
            df["card_embeddings"] = df.apply(
                lambda row: generate_embeddings(json.dumps(row["agent_card"])), axis=1
            )
            return df
        logger.info("Done generating embeddings for agent cards")
    except Exception as e:
        logger.error(f"An unexpected error occurred : {e}.", exc_info=True)
        return None


def serve(host, port, transport):
    """Initializes and runs the Agent Cards MCP server.
    Args:
        host: The hostname or IP address to bind the server to.
        port: The port number to bind the server to.
        transport: The transport mechanism for the MCP server (e.g., 'stdio', 'sse').
    Raises:
        ValueError: If the 'GOOGLE_API_KEY' environment variable is not set.
    """

    init_api_key()

    mcp = FastMCP("agent-cards", host=host, port=port)

    df = build_agent_card_embeddings()

    @mcp.tool(
        name="find_agent",
        description="Finds the most relevant agent card based on a natural language query string.",
    )
    def find_agent(query: str) -> str:
        """Finds the most relevant agent card based on a query string.

        This function takes a user query, typically a natural language question or a task generated by an agent,
        generates its embedding, and compares it against the
        pre-computed embeddings of the loaded agent cards. It uses the dot
        product to measure similarity and identifies the agent card with the
        highest similarity score.

        Args:
            query: The natural language query string used to search for a
                   relevant agent.

        Returns:
            The json representing the agent card deemed most relevant
            to the input query based on embedding similarity.
        """
        query_embedding = genai.embed_content(
            model=MODEL, content=query, task_type="retrieval_query"
        )
        dot_products = np.dot(
            np.stack(df["card_embeddings"]), query_embedding["embedding"]
        )
        best_match_index = np.argmax(dot_products)
        logger.debug(
            f"Found best match at index {best_match_index} with score {dot_products[best_match_index]}"
        )
        return df.iloc[best_match_index]["agent_card"]

    @mcp.tool()
    def query_places_data(query: str):
        """
        Args:
            query : The text string to search for (e.g., "Italian restaurants in London").


        Returns:
            A dictionary containing the API response (parsed JSON), or None if an error occurs.
        """
        logger.info(f"Search for places : {query}")
        api_key = os.getenv("GOOGLE_PLACES_API_KEY")
        if not api_key:
            logger.info("GOOGLE_PLACES_API_KEY is not set")
            return {"places": []}

        headers = {
            "X-Goog-Api-Key": api_key,
            "X-Goog-FieldMask": "places.id,places.displayName,places.formattedAddress",
            "Content-Type": "application/json",
        }
        payload = {"textQuery": query, "languageCode": "en", "maxResultCount": 10}

        try:
            response = requests.post(PLACES_API_URL, headers=headers, json=payload)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.HTTPError as http_err:
            logger.info(f"HTTP error occurred: {http_err}")
            logger.info(f"Response content: {response.text}")
        except requests.exceptions.ConnectionError as conn_err:
            logger.info(f"Connection error occurred: {conn_err}")
        except requests.exceptions.Timeout as timeout_err:
            logger.info(f"Timeout error occurred: {timeout_err}")
        except requests.exceptions.RequestException as req_err:
            logger.info(f"An unexpected error occurred with the request: {req_err}")
        except json.JSONDecodeError:
            logger.info(
                f"Failed to decode JSON response. Raw response: {response.text}"
            )

        return {"places": []}

    @mcp.tool()
    def query_travel_data(query: str):
        """
        "name": "query_travel_data",
        "description": "Retrieves the most up-to-date, ariline, hotel and car rental availability. Helps with the booking.
        This tool should be used when a user asks for the airline ticket booking, hotel or accommodation booking, or car rental reservations.”,
        "parameters": {
            "type": "object",
            "properties": {
            “query": {
                "type": "string",
                "description": “A SQL to run against the travel database.”
            }
            },
            "required": [“query”]
        }
        """
        logger.info(f"Query sqllite : {query}")

        if not query or not query.strip().upper().startswith("SELECT"):
            raise ValueError(f"In correct query {query}")

        try:
            with sqlite3.connect(SQLLITE_DB) as conn:
                conn.row_factory = sqlite3.Row
                cursor = conn.cursor()
                cursor.execute(query)
                rows = cursor.fetchall()
                result = {"results": [dict(row) for row in rows]}
                return json.dumps(result)
        except Exception as e:
            logger.error(f"Exception running query {e}")
            logger.error(traceback.format_exc())
            if "no such column" in e:
                return {
                    "error": f"Please check your query, {e}. Use the table schema to regnerate the query"
                }
            return {"error": {e}}

    # @mcp.tool()
    def book_flights(
        departure_airport: str,
        arrival_airport,
        start_date: str,
        end_date: str,
        travel_class: str = "Economy",
    ) -> Dict[str, Any]:
        """Searches for one-way or round-trip flights and returns results in a single dictionary.

        This function queries a flight data source, Serp API,
        to find available flight itineraries matching the specified
        airports and dates. Dates must be provided in 'YYYY-MM-DD' format.

        Unlike functions returning a list of flights, this function returns a
        single dictionary structure which might contain multiple flight options
        nested within it, along with potentially summary information or status.

        Example:
        Book round-trip air tickets from San Francisco (SFO) to London (any major airport) departing on June 20, 2025, and returning on July 10, 2025.

        Args:
            departure_airport (str): The departure airport code (e.g., "SFO")
            arrival_airport (str): The arrival airport code (e.g., "LHR")
            start_date (str): Trip Start Date. The desired date for the outbound flight,
                                as a string in 'YYYY-MM-DD' format.
            end_date (str): Trip End Date. The desired date for the return (inbound)
                                flight, as a string in 'YYYY-MM-DD' format.
                                Must represent a date on or after the
                                start_date.
            travel_class (str): Flight class of travel.
                                Accepted values
                                    Economy (default)
                                    Premium economy
                                    Business
                                    First

        Returns:
            Dict[str, Any]: A dictionary containing the search results.
            Typical response is below. Content will have hops as well.

            {'meta': None, 'content': [
                    {'type': 'text', 'text': '{
                            "departure_airport": {
                                "name": "San Francisco International Airport",
                                "id": "SFO",
                                "time": "2025-06-03 19:50"
                            },
                            "arrival_airport": {
                                "name": "Heathrow Airport",
                                "id": "LHR",
                                "time": "2025-06-04 14:10"
                            },
                            "duration": 620,
                            "airplane": "Boeing 787",
                            "airline": "United",
                            "airline_logo": "https://www.gstatic.com/flights/airline_logos/70px/UA.png",
                            "travel_class": "Economy",
                            "flight_number": "UA 930",
                            "ticket_also_sold_by": [
                                "Lufthansa",
                                "Austrian",
                                "Brussels Airlines"
                            ],
                            "legroom": "31 in",
                            "extensions": [
                                "Average legroom (31 in)",
                                "Wi-Fi for a fee",
                                "In-seat power & USB outlets",
                                "On-demand video",
                                "Carbon emissions estimate: 460 kg"
                            ],
                            "overnight": true
                        }', 'annotations': None
                    }
                ], 'isError': False
            }
        """
        logger.info(
            f"Book Flights tool with inputs {departure_airport}, {arrival_airport}, {start_date}, {end_date}"
        )
        if not os.getenv("SERPAPI_API_KEY"):
            logger.error("SERPAPI_API_KEY is not set")
            raise ValueError("SERPAPI_API_KEY is not set")
        try:
            client = serpapi.Client(api_key=os.getenv("SERPAPI_API_KEY"))
            params = {
                "engine": "google_flights",
                "departure_id": departure_airport,
                "arrival_id": arrival_airport,
                "outbound_date": start_date,
                "return_date": end_date,
                "currency": "USD",
            }
            results = client.search(params)
            data = results.as_dict()
            logger.debug(f"SerpAPI Flights Data: {data}")
            # return json.dumps(data)
            return_data = data["best_flights"][0]["flights"]
            # logger.info(f"Return data type {type(return_data)}, data {return_data}")
            logger.debug(f"Flights Return Data: {return_data}")
            return_data[0]["price"] = data["best_flights"][0]["price"]
            logger.debug(f"Flights Return Data: {return_data}")
            return return_data
            # return data["best_flights"][0]["flights"]
        except Exception as e:
            logger.error("Exception when trying to search flights")
            logger.error(traceback.format_exc())
            raise e

    # @mcp.tool()
    def book_rental_car(
        location: str,
        start_date: str,
        end_date: str,
    ) -> Dict[str, Any]:
        """Search for and reserve a rental car.

        This tool allows you to book a rental car at a specified location for a given date range.
        Example:
            Book a SUV rental car in London June 20 to July 10, 2025:

            {
                "start_date": "2025-06-20",
                "end_date": "2025-07-10",
                "location": "London",
                "car_type": "SUV",
                "registration": "ABC123",
                "status": "booking_complete",
                "price": "1200 USD",
                "description": "Your SUV booking is confirmed at London City Airport."
            }

        Args:
            location (str): The city or airport code where you want to pick up the car (e.g., "London", "LAX", "JFK").
            start_date (str): The pickup date in 'YYYY-MM-DD' format.
            end_date (str): The return date in 'YYYY-MM-DD' format. Must be on or after start_date.

        Returns:
            A dictionary containing the complete booking details including:
            - start_date: The confirmed pickup date
            - end_date: The confirmed return date
            - location: The pickup location
            - car_type: The type of vehicle booked
            - registration: The vehicle registration number
            - status: The status of the booking (e.g., "booking_complete", "pending")
            - price: The total cost including any fees
            - description: Additional booking information

        """
        logger.info(
            f"Book Car Rental tool with inputs {location}, {start_date}, {end_date}"
        )
        try:
            date_format = "%Y-%m-%d"

            no_cars_start_date = datetime.strptime("2025-06-06", date_format)
            no_cars_end_date = datetime.strptime("2025-06-15", date_format)

            start_date = datetime.strptime(start_date, date_format)
            end_date = datetime.strptime(end_date, date_format)
            logger.info(
                f"{start_date} - {end_date}, No Cars {no_cars_start_date} - {no_cars_end_date}"
            )
            if (start_date <= no_cars_start_date <= end_date) or (
                start_date <= no_cars_end_date <= end_date
            ):
                return {
                    "start_date": start_date,
                    "end_date": end_date,
                    "location": location,
                    "car_type": None,
                    "registration": None,
                    "status": "no_cars_available",
                    "price": "0 USD",
                    "description": f"No cars available during {start_date} - {end_date}. Please try with different dates.",
                }

            return {
                "start_date": start_date,
                "end_date": end_date,
                "location": location,
                "car_type": "SUV",
                "Registration": "4H454",
                "status": "booking_complete",
                "price": "1100 USD",
                "description": "Booking Complete",
            }
        except Exception as e:
            logger.error("Exception when trying to search cars")
            logger.error(traceback.format_exc())
            raise e

    # @mcp.tool()
    def book_hotels(
        location: str,
        check_in_date: str,
        check_out_date: str,
        hotel_class: Optional[str],
    ) -> Dict[str, Any]:
        """Searches for and books hotels returning results in a dictionary.

        This function queries a hotel data source, Serp API,
        to find available hotels matching the specified
        criteria dates. Dates must be provided in 'YYYY-MM-DD' format.

        Example: Book a luxury hotel near St. Pancras, London, for 20 nights, starting June 20, 2025.

        Args:
            location (str): Natural language location criteria (e.g., "Central London")
            check_in_date (str): Checkin date at the hotel
            check_out_date (str): Checkout date at the hotel
                                Must represent a date after check_in_date
            hotel_class (str): Optional class of the hotel, 5 - 5-star hotel, 4 - 4-start Hotel, Luxury Hotel etc.

        Returns:
            Dict[str, Any]: A dictionary containing the search results.
            Typical response contains the section below.

            "properties": [
                {
                "type": "hotel",
                "name": "The Ritz-Carlton, Bali",
                "description": "Zen-like quarters, some with butler service, in an upscale property offering refined dining & a spa.",
                "sponsored": true,
                "gps_coordinates": {
                    "latitude": -8.830670999999999,
                    "longitude": 115.21533099999999
                },
                "check_in_time": "3:00 PM",
                "check_out_time": "12:00 PM",
                "rate_per_night": {
                    "lowest": "$347",
                    "extracted_lowest": 347,
                    "before_taxes_fees": "$287",
                    "extracted_before_taxes_fees": 287
                }
            ]
        """
        logger.info(
            f"Book Hotels tool with inputs {location}, {check_in_date}, {check_out_date} {hotel_class}"
        )
        if not os.getenv("SERPAPI_API_KEY"):
            logger.error("SERPAPI_API_KEY is not set")
            raise ValueError("SERPAPI_API_KEY is not set")
        try:
            client = serpapi.Client(api_key=os.getenv("SERPAPI_API_KEY"))
            params = {
                "engine": "google_hotels",
                "q": location,
                "check_in_date": check_in_date,
                "check_out_date": check_out_date,
                "hotel_class": hotel_class if hotel_class else "3,4,5",
            }
            results = client.search(params)
            data = results.as_dict()
            logger.debug(f"Hotels Return Data: {data}")
            return_data = data["properties"][0]
            if "total_rate" in data["properties"][0]:
                return_data["total_rate_usd"] = data["properties"][0]["total_rate"][
                    "lowest"
                ]
            return return_data
        except Exception as e:
            logger.error("Exception when trying to search hotels")
            logger.error(traceback.format_exc())
            raise e

    @mcp.resource("resource://agent_cards/list", mime_type="application/json")
    def get_agent_cards() -> dict:
        """Retrieves all loaded agent cards as a json / dictionary for the MCP resource endpoint.

        This function serves as the handler for the MCP resource identified by
        the URI 'resource://agent_cards/list'.

        Returns:
            A json / dictionary structured as {'agent_cards': [...]}, where the value is a
            list containing all the loaded agent card dictionaries. Returns
            {'agent_cards': []} if the data cannot be retrieved.
        """
        resources = {}
        logger.info("Starting read resources")
        resources["agent_cards"] = df["card_uri"].to_list()
        return resources

    @mcp.resource("resource://agent_cards/{card_name}", mime_type="application/json")
    def get_agent_card(card_name: str) -> dict:
        """Retrieves an agent card as a json / dictionary for the MCP resource endpoint.

        This function serves as the handler for the MCP resource identified by
        the URI 'resource://agent_cards/{card_name}'.

        Returns:
            A json / dictionary
        """
        resources = {}
        logger.info(f"Starting read resource resource://agent_cards/{card_name}")
        resources["agent_card"] = (
            df.loc[
                df["card_uri"] == f"resource://agent_cards/{card_name}", "agent_card"
            ]
        ).to_list()

        return resources

    logger.info(f"Agent cards MCP Server at {host}:{port} and transport {transport}")
    mcp.run(transport=transport)
